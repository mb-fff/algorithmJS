# 课程说明

1. 通过该课程的学习，能够完成前端面试题中的大部分算法题
2. 通过该课程的学习，提升对后续前端课程的底层代码分析能力
3. **通过该课程的学习，提升开发思维和代码转换能力**

## 常见问题

1. **什么是数据结构？**

   用于表示数据关系的结构

   常见的数据结构有：数组、链表、树、图等

2. **什么是算法？**

   根据已知数据得到结果数据的计算方法

   常见的算法有：穷举法、分治法、贪心算法、动态规划

3. **数据结构和算法有什么关系？**

   数据结构关心的是如何使用合适的结构存储数据

   算法关心的是计算过程

   有了相应的数据结构，免不了对这种数据结构的各种变化进行运算，所以，很多时候，某种数据结构都会自然而然的搭配不少算法。

4. **数据结构和算法课程使用什么计算机语言？**

   数据结构和算法属于计算机基础课程，**它们和具体的语言无关**，用任何语言都可以实现。

   本课程采用JavaScript语言。

5. **配置要求**

   |        |                           最低配置                           |                          推荐配置                          |
   | :----: | :----------------------------------------------------------: | :--------------------------------------------------------: |
   |  知识  | 变量、判断、循环、数组、函数、<br />构造函数、值类型和引用类型 | 除最低配置外，加上递归、作用域链、<br />执行上下文、执行栈 |
   | 代码量 |                            500行                             |                           3000行                           |
   | 练习量 |                           3个效果                            |                          10个效果                          |

6. **课件使用什么软件打开**

   课件是一个`markdown`文件，建议使用`Typora`打开效果最佳

   `Typora`下载地址：https://www.typora.io/

   

# 递归知识回顾

递归（recursion）是**函数式编程思想**的产物，它使用数学函数的思想进行运算，只要在数学逻辑上是合理的，即代码中的函数一定合理

**使用递归时，无须深究其运行过程！**

> 斐波拉契数列的特点是：第1位和第2位固定为1，后面的位，其数字等于前两位之和，比如：
>
> [1, 1, 2, 3, 5, 8, 13, 21, ......]
>
> 求斐波拉契数列第n位的值，n>0
>
> 如果使用函数`f(n)`来表示斐波拉契数列第n位的值，通过数学分析，可以轻松得到：
>
> ```
> f(1) = 1
> f(2) = 1
> f(n) = f(n-1) + f(n-2)
> ```
>
> 以上等式考虑到了所有情况，并且在数学逻辑上是合理的，因此，可以轻松书写到代码中：
>
> ```js
> // 求斐波拉契数列第n位的值
> function f(n){
> 	if(n === 1 || n === 2){
>  		return 1;
> 	}
> 	return f(n-1) + f(n-2);
> }
> ```



# 线性结构

线性结构是数据结构中的一种分类，用于表示一系列的元素形成的有序集合。

常见的线性结构包括：数组、链表、栈、队列

## 数组

> 特别注意：这里所说的数组是数据结构中的数组，和JS中的数组不一样

**数组是一整块连续的内存空间，它由固定数量的元素组成，数组具有以下基本特征：**

1. 整个数组占用的内存空间是连续的

2. 数组中元素的数量是固定的（不可增加也不可减少），创建数组时就必须指定其长度

3. 每个元素占用的内存大小是完全一样的

   <img src="http://mdrs.yuanjin.tech/img/20200724152609.png" alt="image-20200724152609691" style="zoom:50%;" />

根据数组的基本特征，我们可以推导出**数组具有以下特点**：

1. 通过下标寻找对应的元素效率极高，因此遍历速度快
2. 无法添加和删除数据，虽然可以通过某种算法完成类似操作，但会增加额外的内存开销或时间开销
3. 如果数组需要的空间很大，可能一时无法找到足够大的连续内存

**JS中的数组**

在ES6之前，JS没有真正意义的数组，所谓的Array，实际上是一个对象。

ES6之后，出现真正的数组（类型化数组），但是由于只能存储数字，因此功能有限

目前来讲，JS语言只具备不完善的数组（类型化数组）

## 链表

为弥补数组的缺陷而出现的一种数据结构，**它具有以下基本特征**：

1. 每个元素除了存储数据，需要有额外的内存存储一个引用（地址），来指向下一个元素

2. 每个元素占用的内存空间并不要求是连续的

3. 往往使用链表的第一个节点（根节点）来代表整个链表

   ![image-20200724152732227](http://mdrs.yuanjin.tech/img/20200724152732.png)

根据链表的基本特征，我们可以推导出**它具有以下特点**：

1. 长度是可变的，随时可以增加和删除元素
2. 插入和删除元素的效率极高
3. 由于要存储下一个元素的地址，会增加额外的内存开销
4. 通过下标查询链表中的某个节点，效率很低，因此链表的下标遍历效率低

**手动用代码实现链表**

实际上，很多语言本身已经实现了链表，但链表作为一种基础的数据结构，通过手写代码实现链表，不仅可以锻炼程序思维和代码转换能力，对于后序的复杂数据结构的学习也是非常有帮助的。

因此，手写链表是学习数据结构和算法的一门基本功

手写一个链表结构，并**完成一些链表的相关函数**，要实现以下功能：

1. 遍历打印
2. 获取链表的长度
3. 通过下标获取链表中的某个数据
4. 通过下标设置链表中的某个数据
5. 在链表末尾加入一个新节点
6. 在链表某一个节点之后加入一个新节点
7. 删除一个链表节点

# 排序算法

1. **选择排序 Selection Sort**

   ![img](https://www.runoob.com/wp-content/uploads/2019/03/selectionSort.gif)

   

2. **冒泡排序 Bubble Sort**

   ![img](https://www.runoob.com/wp-content/uploads/2019/03/bubbleSort.gif)

   

3. **快速排序 Quick Sort**

   选择一个数（比如序列的最后一位）作为基准数，将整个序列排序成两部分，一部分比该数小，另一部分比该数大，基准数在中间，然后对剩余的序列做同样的事情，直到排序完成

   

   <img src="http://mdrs.yuanjin.tech/img/20200725161229.png" alt="image-20200725161229707" style="zoom:50%;" />

   问题被转换为了：如何对数组的某个区域进行快速排序

1) 选择4作为基准数，排序成为：(3, 1) 4 (7, 6, 5)
2) 对于3,1， 继续使用该方式排序，得到：  (1, 3) 4 (7,6,5)
3) 对于7,6,5，继续使用该方式排序，得到： (1, 3) 4  (5,6,7)
4) 排序完成

# 查询算法

1. **顺序查找 Inorder Search**

   即普通的遍历，属于算法的穷举法，没啥好解释的

2. **二分查找 Binary Search**

   如果一个序列是一个排序好的序列，则使用二分查找可以极大的缩短查找时间

   具体的做法是：

   查找该序列中间未知的数据
      1) 相等，找到
      2) 要找的数据较大，则对后续部分的数据做同样的步骤
      3) 要找的数据较小，则对前面部分的数据做同样的步骤

3. **插值查找 Interpolation Search**

   插值查找是对二分查找的进一步改进

   如果序列不仅是一个排序好的序列，而且序列的步长大致相同，使用插值查找会更快的找到目标。

   插值查找基于如下假设：下标之间的距离比和数据之间的距离比大致相同

   <img src="http://mdrs.yuanjin.tech/img/20200725191649.png" alt="image-20200725191649549" style="zoom:50%;" />

   于是有

   ```
   (target - a) / (g - a) ≈ (mid - minIndex) / (maxIndex - minIndex)
   ```

   从而有

   ```
   mid ≈ (target - a) / (g - a) * (maxIndex - minIndex) + minIndex
   ```

   

# 树

树是一个类似于链表的二维结构，每个节点可以指向0个或多个其他节点

<img src="http://mdrs.yuanjin.tech/img/20200726141135.png" alt="image-20200726141135563" style="zoom:50%;" />

树具有以下特点：

1. 单根：如果一个节点A指向了另一个节点B，仅能通过A直接找到B节点，不可能通过其他节点直接找到B节点
2. 无环：节点的指向不能形成环

树的术语：

1. 结点的度：某个节点的度 = 该节点子节点的数量
2. 树的度：一棵树中，最大的节点的度为该树的度
3. 结点的层：从根开始定义起，根为第1层，根的子结点为第2层，以此类推；
4. 树的高度或深度：树中结点的最大层次
5. 叶子节点：度为0的结点称为叶结点；
6. 分支节点：非叶子节点
7. 子节点、父节点：相对概念，如果A节点有一个子节点B，则A是B的父节点，B是A的子节点
8. 兄弟节点：如果两个节点有同一个父节点，则它们互为兄弟节点
9. 祖先节点：某个节点的祖先节点，是从树的根到该节点本身经过的所有节点
10. 后代节点：如果A是B的祖先节点，B则是A的后代节点

树的代码表示法：

```js
function Node(value){
    this.value = value;
    this.children = [];
}
```

# 二叉树

如果一颗树的度为2，则该树是二叉树

<img src="http://mdrs.yuanjin.tech/img/20200726143113.png" alt="image-20200726143113778" style="zoom: 50%;" />

二叉树可以用下面的代码表示

```js
function Node(value){
    this.value = value;
    this.left = null;
    this.right = null;
}
```

## 二叉树的相关算法

编写各种函数，实现下面的功能

1. 对二叉树遍历打印
   1. 前(先)序遍历 DLR
   2. 中序遍历 LDR
   3. 后序遍历 LRD
2. 根据前序遍历和中序遍历结果，得到一颗二叉树
3. 计算树的深度
4. 查询二叉树 
   1. 深度优先 Depth First Search
   2. 广度优先 Breadth First Search
5. 比较两棵二叉树，得到它们的差异

# 图的概念

<img src="http://mdrs.yuanjin.tech/img/20200727105122.png" alt="image-20200727105122068" style="zoom:50%;" />

图结构中，一个结点可以链接到任意结点，所有结点链接而成的结构，即为图结构

图结构中的链接可以是有向的，也可以是无向的（双向链接），本文仅讨论双向链接

树结构是一种特殊的图结构

图结构没有根，可以有环，但是在一个图结构中，不能存在两个或以上的孤立结点

可以使用图中任何一个结点表示整个图结构

图结构是一种常见的数据结构，例如网络爬虫抓取的网页就是一种典型的图结构

图结构的代码可表示为：

```js
function Node(value){
    this.value = value;
    this.neighbors = [];
}
```

# 相关算法

1. 查询算法

   和树结构一样，图结构的查询也可以分为深度优先（Depth First Search）和广度优先(Breadth First Search)查询

2. 最小生成树算法

   如果一个图中结点连接而成的边具备某种数值，需要将这些边进行精简，生成一个连接全节点同时总边长最小的树结构，该树称之为最小生成树

   实现最小生成树可以使用Prim算法，从任意一个点出发，连接到该点最短的点，组成一个部落，然后继续连接到该部落最短的点，直到把所有点连接完成

# 贪心算法

面试题：找零问题

示例：假设你有一间小店，需要找给客户46分钱的硬币，你的货柜里只有面额为25分、10分、5分、1分的硬币，如何找零才能保证数额**正确**并且硬币数**最小**

贪心算法：当遇到一个求解**全局最优解问题**时，如果可以将全局问题切分为小的局部问题，并**寻求局部最优解**，局部最优解累计的结果即全局最优解

> 某些情况下，局部最优解累计的结果并不一定是全局最优解

# 动态规划

动态规划：一个求全局最优解的问题，把它分解为多个**重复子问题**，对重复子问题求解，同时缓存那些**重复子过程**

**面试题1：青蛙跳台阶问题**

有N级台阶，一只青蛙每次可以跳1级或两级，一共有多少种跳法可以跳完台阶？

**面试题2：最长公共子序列问题（LCS）**

有的时候，我们需要比较两个字符串的相似程度，通常就是比较两个字符串有多少相同的公共子序列

例如有两个字符串

- LCS算法可以很好的计算出两篇论文的相似度
- 利用LCS，可以计算出搜索关键字与搜索结果的相似度

以上两个字符串的最长公共子序列为：LCS可以计算出的相似度